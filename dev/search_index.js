var documenterSearchIndex = {"docs":
[{"location":"#MLJModelRegistryTools.jl","page":"Home","title":"MLJModelRegistryTools.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tools to maintain the MLJ Model Registry.","category":"page"},{"location":"#What's-this-repository-for?","page":"Home","title":"What's this repository for?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"MLJ (Machine Learning in Julia) is a suite of Julia software packages providing a machine learning toolbox. The MLJ Model Registry is a list of packages providing MLJ interfaces to machine learning models, together with metadata about those models, such as the type of data models can operate on, and their full document strings. This package provides software tools for MLJ maintainers to manage the Model Registry, for example to add the models provided by a new machine learning package providing an MLJ interface for those models. It is not part of the standard MLJ distribution.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The model registry itself is currently hosted by MLJModels.jl (part of the standard MLJ distribution) and lives in this folder.","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"This page contains documentation for non-public API, for maintainers of MLJModelRegistryTools.jl.","category":"page"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry","text":"GenericRegistry\n\nModule providing basic tools to manage a package registry, by which is meant a package environment, together with \"package metata\", in the form of a dictionary of TOML-parsable values, keyed on the environment's package dependencies, which is stored in a TOML file. (This file is called Metadata.toml and is located in the same folder as environment Project.toml file.) Not to be confused with a package registry in the sense of the standard library, Pkg.\n\nMethods\n\nGenericRegistry.dependencies(environment): Get a list of the environment's dependencies (vector of package name strings).\nGenericRegistry.put: Insert an item in the metadata dictionary\nGenericRegistry.get: Inspect the metadata\nGenericRegistry.gc: Remove key-value pairs fromn the metadata for package keys no longer dependencies in the environment. (In any case, get will return nothing for any pkg not currently a dependency.)\nGenericRegistry.run: In a new Julia process, load a package or packages and execute a Julia expression there; results are returned as Future objects, to allow asynchronous run calls. Useful for generating metadata about a package.\nGenericRegistry.close(future): Shut down the process intitiated by the run call that returned future (after calling fetch(future) to get the result of evaluation).\n\nExample\n\nusing Pkg\nenv = \"/Users/anthony/MyEnv\"\nPkg.activate(env)\nPkg.status()\n# Status `~/MyEnv/Project.toml`\n#  [7876af07] Example v0.5.5\n#  [bd369af6] Tables v1.12.1\n\nPkg.activate(temp=true)\nPkg.add(\"MLJModelRegistryTools\")\nusing MLJModelRegistryTools.GenericRegistry\npackages = GenericRegistry.dependencies(env)\n# 2-element Vector{String}:\n#  \"Tables\"\n#  \"Example\"\n\nfuture = GenericRegistry.run([\"Tables\",], :(names(Tables)))\nvalue = fetch(future)\n# 3-element Vector{Symbol}:\n#  :Tables\n#  :columntable\n#  :rowtable\n\nGenericRegistry.close(future)\nGenericRegistry.put(\"Tables\", string.(value), env)\nread(\"/Users/anthony/MyEnv/Metadata.toml\", String)\n# \"Tables = [\"Tables\", \"columntable\", \"rowtable\"]\n\"\n\nGenericRegistry.get(\"Tables\", env)\n# 3-element Vector{String}:\n#  \"Tables\"\n#  \"columntable\"\n#  \"rowtable\"\n\n\n\n\n\n","category":"module"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry.close-Tuple{Any}","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry.close","text":"GenericRegistry.close(future)\n\nShut down the Julia process whose output was encapsulated by the Future instance, future.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry.gc-Tuple{Any}","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry.gc","text":"GenericRegistry.gc(environment)\n\nRemove key-value pairs from the metadata dictionary associated with the specified environment in all cases in which the key is not a package dependency. An optional cleanup operation after removing a package from the environment's dependencies.\n\nDoes not change behaviour of metadata methods.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry.get-Tuple{Any, Any}","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry.get","text":"GenericRegistry.get(pkg, environment)\n\nReturn the metadata associated with package, pkg, if it is a dependency of environment and if pkg is a key in associated metadata dictionary. Otherwise, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry.put-Tuple{Any, Any, Any}","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry.put","text":"GenericRegistry.put(pkg, value, environment)\n\nIn the metata dictionary associated with specified package environment, assign value to the key pkg.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.GenericRegistry.run-Tuple{Any, Any, Any}","page":"Internals","title":"MLJModelRegistryTools.GenericRegistry.run","text":"GenericRegistry.run([setup,] packages, program; environment=nothing)\n\nAssuming a package environment path is specified, do the following in a new Julia process:\n\nActivate environment.\nEvaluate the setup expression, if specified.\nInstantiate the environment.\nimport all packages specified in packages.\nEvaluate the program expression.\n\nThe returned value is a Future object which must be fetched to get the final evaluated expression. Shut the temporary process down by calling GenericRegistry.close on the Future.\n\nStep 3 might typically close by reversing any actions mutating the environment, but remember only the last evaluated expression is passed to the Future.\n\nIf environment is unspecified, then a fresh temporary environment is activated, and the packages listed in packages are manually added between Steps 2 and 3 above.\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.registry_path","page":"Internals","title":"MLJModelRegistryTools.registry_path","text":"MLJModelRegistryTools.registry_path()\n\nPrivate method.\n\nReturn the path to the registry to which management tools such as update are to be applied. Use setpath to change.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MLJModelRegistryTools.metadata","page":"Internals","title":"MLJModelRegistryTools.metadata","text":"metadata(pkg; registry=\"\", check_traits=true)\n\nPrivate method.\n\nExtract the metadata for a package. Returns a Future object that must be fetched to get the metadata. See, MLJModelRegistryTools.update, which calls this method, for more details.\n\nAssumes that MLJModelRegistryTools has been developed into registry if this is non-empty.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MLJModelRegistryTools.encode_dic","page":"Internals","title":"MLJModelRegistryTools.encode_dic","text":"encode_dic(d)\n\nConvert an arbitrary nested dictionary d into a nested dictionary whose leaf values are all strings, suitable for writing to a TOML file (a poor man's serialization). The rules for converting leaves are:\n\nIf it's a Symbol, preserve the colon, as in :x -> \":x\".\nIf it's an AbstractString, apply string function (e.g, to remove SubStrings).\nIn all other cases, except AbstractArrays, wrap in single quotes, as in sum -> \"sum\".\nReplace any # character in the application of Rule 3 with _ (to handle gensym names)\nFor an AbstractVector, broadcast the preceding Rules over its elements.\n\n\n\n\n\n","category":"function"},{"location":"internals/#MLJModelRegistryTools.modeltype_given_constructor-Tuple{Any}","page":"Internals","title":"MLJModelRegistryTools.modeltype_given_constructor","text":"model_type_given_constructor(modeltypes)\n\nPrivate method.\n\nReturn a dictionary of modeltypes, keyed on constructor. Where multiple types share a single constructor, there can only be one value (and which value appears is not predictable).\n\nTypically a model type and it's constructor have the same name, but for wrappers, such as TunedModel, several types share the same constructor (e.g., DeterministicTunedModel, ProbabilisticTunedModel are model types sharing constructor TunedModel).\n\n\n\n\n\n","category":"method"},{"location":"internals/#MLJModelRegistryTools.traits_given_constructor_name","page":"Internals","title":"MLJModelRegistryTools.traits_given_constructor_name","text":"MLJModelRegistryTools.traits_given_constructor_name(pkg; check_traits=true)\n\nBuild and return a dictionary of model metadata as follows: The keys consist of the names of constructors of any model object subtyping MLJModelInterface.Model wherever the package providing the model implementation (assumed to be imported) is pkg. This is the package appearing as the root of MLJModelInterface.load_path(model). The values are corresponding dictionaries of traits, keyed on trait name.\n\nPoor man's serialization, as provided by [MLJRegistry.encode_dic)(@ref), is applied to the dictionary, to make it suitable for writing to TOML files.\n\nAlso, apply smoke tests to the associated trait definitions, assuming check_traits=true.\n\n\n\n\n\n","category":"function"},{"location":"registry_management_tools/#Registry-management-tools","page":"Registry management tools","title":"Registry management tools","text":"","category":"section"},{"location":"registry_management_tools/#Overview","page":"Registry management tools","title":"Overview","text":"","category":"section"},{"location":"registry_management_tools/#MLJModelRegistryTools","page":"Registry management tools","title":"MLJModelRegistryTools","text":"MLJModelRegistryTools\n\nModule providing tools for managing the MLJ Model Registry. To modify the registry:\n\nCreate a local clone of MLJModels.jl, which hosts the registry. After making changes, you will be making a MLJModels.jl pull request.\nIf needed, use Julia's package manager to add or remove items from the list of registered packages in the environment \"/src/registry/\", inside your MLJModels.jl clone. Follow the protocol below.\nIn a new Julia session with MLJModelRegistryTools.jl installed, run using MLJModelRegistryTools to make the management tools available.\nPoint the MLJModelRegistryTools module to the location of the registry itself within your MLJModels.jl clone, using setpath(path_to_registry), as in setpath(\"MyPkgs/MLJModels.jl/src/registry\").\nTo add or update the metadata associated with a package, run update(pkg).\nAssuming this is successful, update the metadata for all packages in the registry by running update().\nWhen satisfied, commit your changes to the clone and make a pull request to the MLJModels.jl repository that you cloned.\n\nimportant: Important\nIn any MLJModels.jl pull request to update the Model Registry you should note the final output of Pkg.status(outdated=true) when you have /src/registry activated.\n\nProtocol for adding new packages to the registry environment\n\nIn your local clone of MLJModels.jl, activate the environment at  \"/src/registry/\".\nupdate the environment\nNote the output of Pkg.status(outdated=true)\nadd the new package\nRepeat steps 2 and 3 above, and investigate any dependency downgrades for which your addition may be the cause.\n\nIf adding the new package results in downgrades to existing dependencies, because your package is not up to date with it's compatibility bounds, then your pull request to register the new models may be rejected.\n\nnote: Note\nRemoving a package from the registry environment does not remove its metadata. However if you call update() to update all package metadata (or call MLJModelRegistryTools.gc()) the metadata for all orphaned packages is removed.\n\n\n\n\n\n","category":"module"},{"location":"registry_management_tools/#Methods","page":"Registry management tools","title":"Methods","text":"","category":"section"},{"location":"registry_management_tools/","page":"Registry management tools","title":"Registry management tools","text":"setpath\nupdate\nMLJModelRegistryTools.gc\nMLJModelRegistryTools.get","category":"page"},{"location":"registry_management_tools/#MLJModelRegistryTools.setpath","page":"Registry management tools","title":"MLJModelRegistryTools.setpath","text":"setpath(path)\n\nPoint MLJModelRegistryTools to the location of the registry to be modified. Ordinarily, this is the absolute path to the subdirectory /src/registry of a local clone of MLJModels.jl.\n\njulia> pwd()\n\"/Users/anthony/GoogleDrive/Julia/MLJ/MLJModels.jl\"\n\njulia> setpath(\"~/GoogleDrive/Julia/MLJ/MLJModels.jl/src/registry\")\n\n\n\n\n\n","category":"function"},{"location":"registry_management_tools/#MLJModelRegistryTools.update","page":"Registry management tools","title":"MLJModelRegistryTools.update","text":"update(pkg; check_traits=true, advanced_options...)\n\nExtract the values of model traits for models in the package pkg, including document strings, and record this in the MLJ model registry (write it to /registry/Metadata.toml).\n\nAssumes pkg is already a dependency in the Julia environment defined at /registry/ and uses the version of pkg consistent with the current environment manifest, after MLJModelRegistryTools.jl has been developed into that environment (it is removed again after the update). See documentation for details on the registration process.\n\njulia> update(\"MLJDecisionTreeInterface\")\n\nReturn value\n\nThe metadata dictionary, keyed on models (more precisely, constructors, thereof).\n\nAdvanced options\n\nwarning: Warning\nAdvanced options are intended primarily for diagnostic purposes.\n\nmanifest=true: Set to false to ignore the registry environment manifest and instead add only the specified packages to a new temporary environment. Useful to temporarily force latest versions if these are being blocked by other packages.\ndebug=false: Calling update opens a temporary Julia process to extract the trait metadata (see MLJModelRegistryTools.GenericRegistry.run). By default, this process is shut down before rethrowing any exceptions that occurs there. Setting debug=true will leave the process open, and also block the default suppression of the remote worker standard output.\n\n\n\n\n\nupdate(; check_traits=true, skip=String[], advanced_options...)\n\nUpdate all packages in the Registry environment that are not specified in skip.\n\njulia> update(skip=[\"MLJBase\", \"MLJScikitlearnInterface\"])\n\nReturn value\n\nA set of all names of all packages for which metadata was recorded.\n\nAdvanced options\n\nnworkers=otherBase.Sys.CPU_THREADS-1-nworkers()): number of workers running package updates in parallel. Metadata is extracted in parallel, but written to file sequentially.\ndebug=false: Set to true to leave temporary processes open; see the update(pkg; ...) document string above.\nmanifest=true: See the update(pkg; ...) document string above.\n\n\n\n\n\n","category":"function"},{"location":"registry_management_tools/#MLJModelRegistryTools.gc","page":"Registry management tools","title":"MLJModelRegistryTools.gc","text":"MLJModelRegistryTools.gc()\n\nRemove the metadata associated with any packages that are no longer in the the model registry.\n\nThis is performed automatically after update(), but not after update(pkg).\n\n\n\n\n\n","category":"function"},{"location":"registry_management_tools/#MLJModelRegistryTools.get","page":"Registry management tools","title":"MLJModelRegistryTools.get","text":"MLJModelRegistryTools.get(pkg)\n\nInspect the model trait metadata recorded in the Model Registry for those models in pkg. Returns a dictionary keyed on model constructor name. Data is in serialized form; see MLJModelRegistryTools.encode_dic.\n\n\n\n\n\n","category":"function"}]
}
